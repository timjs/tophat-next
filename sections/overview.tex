% !TEX root=../main.tex

\section{Grammar}

\subsection{Types}

\usemacro{G-Types}


\subsection{Expressions}

\usemacro{G-Expressions}
\usemacro{G-Pretasks}


\subsection{Values}

\usemacro{G-Values}
\usemacro{G-Tasks}


\subsection{Inputs}

\usemacro{G-Inputs}


\section{Rules}

\subsection{Evaluation rules}

\begin{gather*}
  \boxed{\RelationE}  \Break
  \userule{E-Value}   \Quad
  \userule{E-App}     \Break
  \userule{E-IfTrue}  \Quad
  \userule{E-IfFalse} \Break
  \userule{E-Tuple}   \Quad
  \userule{E-First}   \Quad
  \userule{E-Second}  \Break
  \userule{E-Cons}    \Quad
  \userule{E-Head}    \Quad
  \userule{E-Tail}    \Break
                      \Break
  \userule{E-Enter}   \Quad
  \userule{E-Update}  \Quad
  \userule{E-View}    \Quad
  \userule{E-Pick}    \Break
  \userule{E-Trans}   \Quad
  \userule{E-Step}    \Quad
  \userule{E-Forever} \Break
  \userule{E-Done}    \Quad
  \userule{E-Pair}    \Quad
  \userule{E-Choose}  \Break
  \userule{E-Share}   \Quad
  \userule{E-Assign}  \Quad
  \userule{E-Change}  \Quad
  \userule{E-Watch}
\end{gather*}


\subsection{Typing rules}

\begin{gather*}
  \boxed{\RelationT}    \Break
  \userule{T-Bool}      \Quad
  \userule{T-Int}       \Quad
  \userule{T-String}    \Quad
  \userule{T-Unit}      \Break
  \userule{T-Var}       \Quad
  \userule{T-Abs}       \Quad
  \userule{T-App}       \Break
  \userule{T-Sym}       \Quad
  \userule{T-Loc}       \Quad
  \userule{T-If}        \Break
  \userule{T-Tuple}     \Quad
  \userule{T-First}     \Quad
  \userule{T-Second}    \Break
  \userule{T-Nil}       \Quad
  \userule{T-Cons}      \Quad
  \userule{T-Head}      \Quad
  \userule{T-Tail}      \Break
                        \Break
  \userule{T-Enter}     \Quad
  \userule{T-Update}    \Quad
  \userule{T-View}      \Quad
  \userule{T-Done}      \Break
  \userule{T-Pair}      \Quad
  \userule{T-Choose}    \Quad
  \userule{T-Fail}      \Break
  \userule{T-Trans}     \Quad
  \userule{T-Step}      \Break
  \userule{T-Pick}      \Quad
  \userule{T-Forever}   \Quad
  \userule{T-Share}     \Break
  \userule{T-Assign}    \Quad
  \userule{T-Change}    \Quad
  \userule{T-Watch}
\end{gather*}


\subsection{Normalisation rules}

\begin{gather*}
  \boxed{\RelationN}      \Break
  \userule{N-StepNone}    \Break
  \userule{N-StepFail}    \Break
  \userule{N-StepWait}    \Break
  \userule{N-StepCont}    \Break
                          \Break
  \userule{N-ChooseLeft}  \Break
  \userule{N-ChooseRight} \Break
  \userule{N-ChooseNone}  \Break
                          \Break
	\userule{N-Trans}       \Quad
  \userule{N-Forever}     \Quad
	\userule{N-Pair}        \Break
	\userule{N-Share}       \Quad
	\userule{N-Assign}      \Break
                          \Break
  \userule{N-Done}        \Quad
  \userule{N-Enter}       \Quad
  \userule{N-Update}      \Quad
  \userule{N-View}        \Break
  \userule{N-Pick}        \Quad
  \userule{N-Change}      \Quad
  \userule{N-Watch}       \Quad
  \userule{N-Fail}
\end{gather*}


\subsection{Handling rules}

\begin{gather*}
  \boxed{\RelationH}       \Break
  \userule{H-Enter}        \Quad
  \userule{H-Update}       \Quad
  \userule{H-Change}       \Break
                           \Break
  \userule{H-Pick}         \Quad
  \userule{H-Cont}         \Break
                           \Break
  \userule{H-Trans}        \Quad
  \userule{H-Step}         \Quad
  \userule{H-Forever}      \Break
                           \Break
  \userule{H-PairFirst}    \Quad
  \userule{H-PairSecond}   \Break
  \userule{H-ChooseFirst}  \Quad
  \userule{H-ChooseSecond}
\end{gather*}

\bigskip


\subsection{Fixing rules}

\begin{gather*}
  \boxed{\RelationF} \Break
  \userule{F-Done}   \Quad
  \userule{F-Loop}
\end{gather*}

\bigskip


\subsection{Interaction rules}

\begin{gather*}
  \boxed{\RelationI} \Break
  \userule{I-Handle}
\end{gather*}


\subsection{Symbolic rules}

\begin{gather*}
  \boxed{\RelationX} \Break
  \boxed{\RelationS}
\end{gather*}

\fixme{Add transitions for symbolc equivalents of handling and interaction.}


\section{Observations}

\subsection{Value}

\usemacro{O-Value}


\subsection{Failing}

\usemacro{O-Failing}


\subsection{Watching}

\usemacro{O-Watching}


\subsection{Picks}

\usemacro{O-Picks}


\subsection{Inputs}

\usemacro{O-Inputs}

\fixme{Is normalisation of $t_2$ needed in the case of step?}


\subsection{Next}

\fixme{Add observation for \emph{next step hint}.}


\section{Laws}

\subsection{Transforming (functor)}

\begin{equation*}
  \begin{array}{rclr}
    \Identity \Trans t
      &\cong& t
      & \text{(identity)} \\
    (e_1 \circ e_2) \Trans t
      &\cong& e_1 \Trans\ (e_2 \Trans t)
      & \text{(composition)} \\
  \end{array}
\end{equation*}


\subsection{Pairing (applicative/monoidal functor)}

\begin{equation*}
  \begin{array}{rclr}
    \Done \unit \Pair t
      &\cong& t
      & \text{(left identity)} \\
    t \Pair \Done \unit
      &\cong& t
      & \text{(right identity)} \\
    t_1 \Pair\ (t_2 \Pair t_3)
      &\cong& (t_1 \Pair t_2) \Pair t_3
      & \text{(associativity)} \\
    (\lambda \tuple{x_1, x_2}. \tuple{e_1\ x_1, e_2\ x_2}) \Trans\ (t_1 \Pair t_2)
      &\cong& (e_1 \Trans t_1) \Pair\ (e_2 \Trans t_2)
      & \text{(naturality)} \\
  \end{array}
\end{equation*}


\subsection{Choosing}

\begin{equation*}
  \begin{array}{rclr}
    t_1 \Choose\ (t_2 \Choose t_3)
      &\cong& (t_1 \Choose t_2)\ \Choose t_3
      & \text{(associativity)} \\
    \Done e \Choose t
      &\cong& \Done e
      & \text{(left catch)} \\
    t \Choose \Done e
      &\not\cong& \Done e
      & \text{(right catch)} \\
    & & & \\
    e \Trans\ (t_1 \Choose t_2)
      &\cong& (e \Trans t_1)\ \Choose\ (e \Trans t_2)
      & \text{(distributivity)} \\
    & & & \\
    t_0 \Pair\ (t_1 \Choose t_2)
      &\cong& (t_0 \Choose t_1) \Pair\ (t_0 \Choose t_2)
      & \text{(left pair distributivity)} \\
    (t_1 \Choose t_2) \Pair t_0
      &\cong& (t_1 \Choose t_0) \Pair\ (t_2 \Choose t_0)
      & \text{(right pair distributivity)} \\
    & & & \\
    t_0 \Step \lambda x. (t_1 \Choose t_2)
      &\cong& (t_0 \Step \lambda x. t_1)\ \Choose\ (t_0 \Step \lambda x. t_2)
      & \text{(left step distributivity)} \\
    (t_1 \Choose t_2)\ \Step e
      &\cong& (t_1 \Step e) \Choose\ (t_2 \Step e)
      & \text{(right step distributivity)} \\
  \end{array}
\end{equation*}

\subsection{Failing}

\begin{equation*}
  \begin{array}{rclr}
    \Fail \Choose t
      &\cong& t
      & \text{(left identity)} \\
    t \Choose \Fail
      &\cong& t
      & \text{(right identity)} \\
    & & & \\
    e \Trans \Fail
      &\cong& \Fail
      & \text{(annihilation)} \\
    & & & \\
    \Fail \Pair t
      &\not\cong& \Fail
      & \text{(left pair annihilation)} \\
    t \Pair \Fail
      &\not\cong& \Fail
      & \text{(right pair annihilation)} \\
    & & & \\
    \Fail \Step e
      &\cong& \Fail
      & \text{(left step annihilation)} \\
    t \Step \lambda x. \Fail
      &\not\cong& \Fail
      & \text{(right step annihilation)} \\
  \end{array}
\end{equation*}


\subsection{Stepping (monad)}

\begin{equation*}
  \begin{array}{rclr}
    \Done x \Step g
      &\cong& g\ x
      & \text{(left identity)} \\
    t \Step\ (\lambda y. \Done y)
      &\cong& t
      & \text{(right identity)} \\
    (t \Step g) \Step h
      &\cong& t \Step\ (\lambda y. g\ y \Step h)
      & \text{(associativity)}
  \end{array}
\end{equation*}
